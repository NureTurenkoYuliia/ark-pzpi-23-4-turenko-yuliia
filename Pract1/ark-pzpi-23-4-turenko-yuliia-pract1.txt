МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ










ЗВІТ
з дисципліни «Аналіз та рефакторінг коду» 
з практичного заняття №1







Виконала:	Перевірив:
ст. гр. ПЗПІ-23-4	старший викладач каф. ПІ
Туренко Ю.С.	Сокорчук І.П.











ХАРКІВ 2025

1 Правила оформлення програмного коду (Code Convention)
1.1 Історія змін

№ДатаВерсія звітуОпис змін та виправлень121.100.1Створено розділи «Мета» і «Завдання»223.100.2Створено розділи «Опис виконаної роботи» та «Висновок», Додано матеріали у Додатки
1.2 Мета
     Ознайомитися з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для мови програмування C, а також навчитися аналізувати та рефакторити код для покращення його якості.


1.3 Завдання
     Обрати мову програмування, дослідити основні рекомендації для написання якісного коду у цій мові, продемонструвати ці рекомендації на прикладах коду, обґрунтувати кожну рекомендацію і надати детальні пояснення. Для кожного прикладу мають бути наведені фрагменти коду.


1.4 Опис виконаної роботи
     Що таке MISRA і чому вона важлива?
     MISRA – набір інструкцій із кодування для безпечного та надійного використання мови C у критичних сферах (автомобільна, авіація, медичні пристрої тощо). MISRA C:2012 визначає правила й директиви, які допомагають зменшити ризик помилок через неясні частини мови C, реалізаційні відмінності та небезпечні конструкції.
     Стилі іменування та назви
     Правило / рекомендація: 
* використовувати однозначні, консистентні іменування для змінних, функцій, макросів та типів; 
* розділяти імена за семантикою, уникайте односимвольних імен поза локальними лічильниками; 
* макроси в UPPER_SNAKE_CASE; 
* typedef-типи з суфіксом _t або іншим стилем, узгодженим у проєкті.
     Чому важливо: полегшені навігація, рефакторинг та кодрев’ю.
     Наслідки недотримання: плутанина між різними значеннями, помилки при повторному використанні.
     Правила про типи, перетворення і уникнення невизначеної поведінки
     Ключова ідея MISRA: виявляти і усувати небезпечні перетворення типів, арифметику з переповненням, неоднозначні вирази. 
     Наслідки недотримання: неочікувана поведінка на іншому компіляторі чи архітектурі – загроза безпеці.
     Приклад як добре:
      #include <limits.h>
      #include <stdint.h>
      #include <stdbool.h>
      bool add_will_overflow_int32(int32_t x, int32_t y, int32_t *result) {
          if (y > 0 && x > INT32_MAX - y) {
              return true;
          }
          if (y < 0 && x < INT32_MIN - y) {
              return true;
          }
          *result = x + y;
          return false;
      }

     Обробка помилок та валідація вхідних даних
     Рекомендація: всі зовнішні входи повинні валідуватися; кожна функція має чітко визначений контракт і способи повернення помилок. MISRA наголошує на документуванні важливих важливих припущень (assumptions) і обмежень (constraints).
     Чому важливо: прозорість, чіткий інтерфейс, покращені безпека й підтримка.
     Наслідки недотримання: непередбачувані помилки, проблеми безпеки і складне налагодження.
     Приклад того, що явні коди помилок полегшують обробку та запис в лог:

      typedef enum {
          E_OK = 0,
          E_NULLPTR,
          E_INVALID_PARAM,
          E_OVERFLOW
      } error_t;
      error_t compute_sum(const int32_t *arr, size_t n, int32_t *out_sum) {
          if (arr == NULL || out_sum == NULL) {
              return E_NULLPTR;
          }
          int64_t tmp = 0;
          for (size_t i = 0; i < n; ++i) {
              tmp += arr[i];
              if (tmp > INT32_MAX || tmp < INT32_MIN) {
                  return E_OVERFLOW;
              }
          }
          *out_sum = (int32_t)tmp;
          return E_OK;
      }
      

     Управління потоками виконання та контроль умов (зрозуміла логіка, без «глибоких» вкладень)
     Рекомендація: уникати глибоких вкладень, довгих функцій і складних умов. Натомість замінювати на менші функції, ранні виходи (early return), а також ясно документувати кожен branch і перевірку.
     Чому важливо: полегшені кодрев’ю і тестування, покращене розуміння логіки при читанні коду та зменшення помилок.
     Наслідки недотримання: високий ризик помилок, 
складна підтримка й потенційна заплутаність коду.
     Приклад того, що ранні перевірки спрощують читання і тестування:
     Погано:
      int process(packet_t *p) {
          if (p != NULL) {
              if (validate(p)) {
                  if (p->len > 0) {
                      /* велика логіка тут... */
                  }
              }
          }
          return -1;
      }
     
     Добре:
      int process(packet_t *p) {
          if (p == NULL) {
              return -1;
          }
          if (!validate(p)) {
              return -1;
          }
          if (p->len == 0) {
              return -1;
          }
          /* менша, конкретна логіка */
          return 0;
      }
      
     Уникати непередбачуваної динамічної алокації в критичних модулях
     Рекомендація: у реальних системах реального часу і safety-критичних додатках рекомендується контролювати або уникати динамічної алокації (malloc) у runtime коді. Якщо використовується - варто застосувати механізми пулів, слоти або статичну ініціалізацію. 
     Приклад як добре:
      #define POOL_SIZE 10
      static uint8_t pool_storage[POOL_SIZE][256];
      static bool pool_used[POOL_SIZE];
      void *pool_alloc(void) {
          for (int i = 0; i < POOL_SIZE; ++i) {
              if (!pool_used[i]) {
                  pool_used[i] = true;
                  return pool_storage[i];
              }
          }
          return NULL; /* явна обробка */
      }
     
     Використання enum і констант замість макросів
     Рекомендація: мінімізувати використання #define для констант; краще використовувати enum або static const (в залежності від контексту) і обмежувати видимість через static або внутрішні модулі. MISRA заохочує чіткий спосіб організації констант і уникнення макросів, що змінюють синтаксис. 
     Приклад як погано:
      #define MAX 100
      #define SQR(x) ((x)*(x))  /* макроси */
     
     Приклад як погано:
      enum { MAX_ITEMS = 100 };
      static inline int sqr_int(int x) {
          return x * x;
      }
      
     Мінімізація області видимості
     Рекомендація: мінімізувати область видимості змінних і функцій — оголошувати їх у найменшому можливому контексті (static у файлі, локальні в межах функції).
     Чому важливо: це зменшує ризик випадкових змін даних з інших частин коду та спрощує аналіз залежностей при перевірці або модифікації програми. 
     Наслідки недотримання: конфлікти імен, побічні ефекти та складність у відстеженні помилок під час налагодження.
     Як привести код у відповідності до правил?
* Статичний аналіз «зліпок» – пропустити проект через статичний аналізатор (MISRA-профіль) і зберегти звіт.
* Написати тести (unit/integration) – для найбільш ризикованих модулів; без тестів – не починати великий refactor.
* CI і регресійні тести – додати автоматичні перевірки (статичний аналіз + unit tests) в CI.
* Малі кроки (refactor small) – змінювати по одному модулю або функції; кожен крок рефакторингу має супроводжуватися тестом і оновленим звітом статичного аналізу.
     Інструменти статичного аналізу та підтримки MISRA: Parasoft C/C++ test, FlexeLint, Coverity, Klocwork, cppcheck, а також комерційні модулі від MathWorks. 


1.5 Висновок
     Дотримання рекомендацій MISRA безпосередньо сприяє покращенню загальної якості коду. Покращеється узгодженість, надійність і портативність. Застосовуючи правила кодування та найкращі практики, MISRA C зменшує ймовірність появи помилок, невизначеної поведінки або вразливостей.

ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: https://www.youtube.com/watch?v=8wefCyUeQnI 
Хронологічний опис відеозапису:
00:00 — Вступ 
00:19 — Що таке MISRA і чому вона важлива? 
01:11 — Стилі іменування та назви 
02:13 — Правила про типи, перетворення і уникнення невизначеноої поведінки 
04:37 — Обробка помилок та валідація вхідних даних 
08:18 — Управління потоками виконання та контроль умов 
10:28 — Уникати непередбачуваної динамічної алокації 
11:26 — Використання enum і констант замість макросів 
12:39 — Мінімізація області видимості 
13:24 — Коротко про те, як рефакторити код 
14:15 — Висновки
ДОДАТОК Б
Графічні матеріали


Рисунок Б.1 –  Рекомендації для написання якісного 



Рисунок Б.2 – Що таке MISRA і чому вона важлива


Рисунок Б.3 –  Стилі іменування та назви


Рисунок Б.4 – Правила про типи пеертворення і уникнення невизначеної поведінки


Рисунок Б.5 –  Обробка помилок та валідація вхідних даних


Рисунок Б.6 – Приклад того, що явні коди помилок полегшують обробку та запис в лог


Рисунок Б.7 –  Управління потоками виконання та контроль умов



Рисунок Б.8 – Приклад того, що ранні перевірки спрощують читання і тестування

Рисунок Б.9 –  Уникати непередбачуваної динамічної алокації в критичних модудях



Рисунок Б.10 – Використання enum і констант замість макросів


Рисунок Б.11 –  Мінімізація області видимості



Рисунок Б.12 – Як провести код у відповідності до правил?


Рисунок Б.13 –  Висновки



Рисунок Б.14 – Джерела

Рисунок Б.15 –  Дякую


