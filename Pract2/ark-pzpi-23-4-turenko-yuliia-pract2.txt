МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ










ЗВІТ
з дисципліни «Аналіз та рефакторінг коду» 
з практичного заняття №2







Виконала:	Перевірив:
ст. гр. ПЗПІ-23-4	старший викладач каф. ПІ
Туренко Ю.С.	Сокорчук І.П.











ХАРКІВ 2025

МЕТОДИ РЕФАКТОРИНГУ КОДУ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ

1 ІСТОРІЯ ЗМІН

№ДатаВерсія звітуОпис змін та виправлень118.110.1Створено розділ «Завдання»220.110.2Створено розділи «Опис виконаної роботи» та «Висновок»321.110.3Додано матеріали у Додатки
2 ЗАВДАННЯ
     Обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code». Навести приклади свого особистого коду (з курсових, лабораторних або інших проєктів), який потребує покращення, та продемонструвати застосування обраних методів.

3 ОПИС ВИКОНАНОЇ РОБОТИ
     У процесі розробки серверної логіки в ASP.NET Core Web API код поступово ускладнюється: з’являються дублікати, розгалужені умовні конструкції, методи стають занадто великими. Це ускладнює підтримку проєкту, знижує читабельність і підвищує ризик помилок. Методи рефакторингу Replace Conditional with Polymorphism, Encapsulate Collection та Move Method допомагають структурувати код, скоротити дублювання, підвищити стабільність системи.
     Replace Conditional with Polymorphism – метод рефакторингу, який дозволяє замінити умовну логіку на поліморфізм:
* створюється базовий абстрактний клас або інтерфейс;
* кожен варіант поведінки винесено в окремий клас;
* вибір реалізації виконується фабрикою/DI контейнером.
     Проблема виникає, коли в коді присутня складна умовна логіка (switch, if/else), яка визначає поведінку залежно від типу об’єкта, наприклад:
* тип замовлення;
* спосіб оплати;
* тип нотифікації;
* роль користувача.
Код до рефакторингу (рис. Б.4) має наступні проблеми:
* для кожного нового PaymentType потрібно редагувати метод;
* порушує OCP – код відкритий для модифікацій;
* нелегко тестувати – весь функціонал в одному методі;
* логіка концентрується в одному місці.
Чому Replace Conditional with Polymorphism:
* усуває розгалужену умовну логіку;
* розширення системи через додавання нового класу, а не редагування старого коду;
* тестування простіше;
* зменшує залежності;
* код стає чистим та підтримуваним.
     Кроки рефакторингу коду (рис. Б.5 і Б.6)
     Крок 1 – виявлення умовної логіки (switch, if/else). Визначили місце в коді, де поведінка розгалужується залежно від типу платежу. Саме ця умовна конструкція була основною проблемою.
     Крок 2 – створення абстракції (інтерфейсу): ми ввели інтерфейс IPaymentProcessor, щоб задати єдину поведінку для різних способів оплати. 
     Крок 3 – винесення поведінки в окремі класи. Для кожного типу платежу створено окремий клас, де розміщена відповідна логіка. Тепер кожен спосіб оплати реалізує власні правила замість того, щоб обробляти їх в одному місці.
     Крок 4 – фабрика або DI для вибору потрібного класу. Замість switch використали фабрику, яка повертає відповідну реалізацію на основі типу оплати. Таким чином, логіка вибору тепер структурована і не потребує змін при додаванні нових типів.
     Крок 5 – оновлення сервісу для роботи з абстракціями. Сервіс тепер викликає метод інтерфейсу, а не містить умовну логіку. Це робить його універсальним і набагато простішим.
Переваги отриманого коду:
* код відповідає принципу OCP;
* легке тестування;
* підвищена читабельність;
* масштабованість;
* зменшення дублювання;
* чиста архітектура.
     
     Encapsulate Collection – метод рефакторингу, який робить колекцію приватною і надає тільки контрольовані методи для її зміни.
     Переваги підходу:
* дозволяє гарантувати коректний стан об’єкта;
* усуває пряме втручання ззовні;
* дозволяє додати валідацію, логування, обмеження;
* код легше читати та підтримувати.
     У багатьох проектах ASP.NET Core Web API в доменних моделях або DTO зустрічаються публічні колекції, які призводять до таких проблем: 
* можна напряму змінювати ззовні без контролю;
* порушується інваріантність доменних об’єктів;
* неможливо контролювати додавання/видалення елементів;
* можливий некоректний стан об'єкта.
     Код до рефакторингу (рис. Б.9) має наступні проблеми:
* немає контролю бізнес-логіки (наприклад, uantity > 0);
* немає можливості логувати зміни;
* немає механізму валідації перед додаванням;
* не можна гарантувати правильний стан об’єкта.
     Чому Encapsulate Collection:
* дає змогу контролювати стан об’єкта;
* приховує реалізацію та захищає інваріанти;
* підтримує принципи ООП (інкапсуляція та SRP);
* запобігає непередбачуваним ситуаціям;
* полегшує тестування;
* покращує підтримку та масштабованість.
     Кроки рефакторингу коду (рис. Б.10)
     Крок 1 – сховати колекцію через приватне поле. Закрили прямий доступ до внутрішнього списку, 
     Крок 2 – зробити публічну колекцію тільки для читання. Через IReadOnlyCollection ми дозволяємо отримувати елементи, але не змінювати їх.
     Крок 3 – створити методи для керування колекцією Ми створили методи AddItem і RemoveItem, щоб зміни проходили через контрольовану логіку. Тут можна виконувати валідацію, логування або бізнес-перевірки.
     Крок 4 – оновити клієнтський код.
     Переваги отриманого коду:
* контрольоване управління колекцією;
* інваріантність;
* чиста архітектура;
* безпека даних;
* зручне розширення;
* краща інтеграція з EF Core.
     
     Move Method – метод рефакторингу, який дозволяє перенести метод у той клас, де він справді повинен знаходитись.
     Метод може «жити» не у тому класі, де він логічно повинен бути. Це трапляється, коли:
* метод надто активно використовує дані іншого об’єкта;
* клас стає перевантаженим функціональністю;
* порушується принцип Single Responsibility (SRP);
* логіка стає розпорошеною по сервісах, де їй не місце.
У реальних ASP.NET Core проектах описані проблеми часто бувають у:
* сервісах, що «знають занадто багато»;
* моделях DTO, які не повинні містити логіку;
* контролерах, у які перенесено логіку, що має бути у сервісах.
     Код до рефакторингу (рис. Б.13) має наступні проблеми:
* логіка розкидана: сервіс виконує обчислення, що належать до Order / OrderItem;
* зміна логіки потребує зміни сервісу;
* SRP порушено – сервіс робить не свою роботу;
* тестування ускладнене – потрібно створювати сервіс для логіки елемента замовлення.
     Чому Move Method:
* кожен клас відповідає за власну поведінку;
* логіка ближча до даних, на яких працює;
* зменшення залежностей між сервісами;
* підвищення читабельності коду;
* полегшується тестування.
     Кроки рефакторингу коду (рис. Б.14)
     Крок 1 – виявити метод, що живе «не у тому класі». Ми визначили, що логіка розрахунку суми замовлення в сервісі стосується елементів замовлення та самого замовлення. Це ознака неправильного розташування методу.
     Крок 2 – перенести частину логіки в OrderItem. Ми винесли логіку підрахунку ціни одного товару у метод GetTotal() в класі OrderItem. Тепер саме об’єкт відповідає за свою поведінку.
     Крок 3 – перенести логіку сумування в Order. Логіку об’єднання значень усіх елементів ми перенесли в метод GetOrderTotal() класу Order. Це забезпечило природний розподіл відповідальностей між моделями.
     Крок 4 – спрощення сервісу. Після перенесення логіки сервіс став тонким і простим – він лише викликає методи моделей. Таким чином, він більше не відповідає за бізнес-логіку.
     Переваги отриманого коду
* SRP відновлено;
* проста підтримка;
* менше залежностей;
* легше тестувати;
* зрозуміліша структура;
* можливість масштабування.
     
     
4 ВИСНОВОК
     У результаті виконання даної роботи  були вивчені основні методи рефакторингу коду на основі реальних прикладів. Розглянуті підходи дозволяють побудувати гнучку, добре структуровану та підтримувану серверну архітектуру, що є важливим для сучасного Web API.
ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: https://youtu.be/JV6pXVSfFFA .
Хронологічний опис відеозапису:
* 00:00 – Вступ 
* 01:07 – Опис Replace Conditional with Polymorphism методу 
* 01:47 – Приклад до рефакторінгу (Replace Conditional with Polymorphism) 
* 03:26 – Кроки рефакторінгу (Replace Conditional with Polymorphism) 
* 04:36 – Переваги отриманого коду (Replace Conditional with Polymorphism) 
* 05:05 – Опис Encapsulate Collection 
* 06:06 – Приклад до рефакторінгу (Encapsulate Collection) 
* 07:11 – Кроки рефакторінгу (Encapsulate Collection) 
* 08:01 – Переваги отриманого коду (Encapsulate Collection) 
* 08:30 – Опис Move Method 
* 09:22 – Приклад до рефакторінгу (Move Method) 
* 11:03 – Кроки рефакторінгу (Move Method) 
* 11:52 – Переваги отриманого коду (Move Method) 
* 12:25 – Висновок 

ДОДАТОК Б
Графічні матеріали

Рисунок Б.1 – Титулка


Рисунок Б.2 – Вступ


Рисунок Б.3 – Опис Replace Conditional with Polymorphism методу


Рисунок Б.4 – Приклад до рефакторінгу (Replace Conditional with Polymorphism)


Рисунок Б.5 – Кроки рефакторінгу (Replace Conditional with Polymorphism)


Рисунок Б.6 – Кроки рефакторінгу (Replace Conditional with Polymorphism)


Рисунок Б.7 – Переваги отриманого коду (Replace Conditional with Polymorphism)


Рисунок Б.8 – Опис Encapsulate Collection


Рисунок Б.9 – Приклад до рефакторінгу (Encapsulate Collection)


Рисунок Б.10 – Кроки рефакторінгу (Encapsulate Collection)


Рисунок Б.11 – Переваги отриманого коду (Encapsulate Collection)


Рисунок Б.12 – Опис Move Method


Рисунок Б.13 – Приклад до рефакторінгу (Move Method)


Рисунок Б.14 – Кроки рефакторінгу (Move Method)


Рисунок Б.15 – Переваги отриманого коду (Move Method)


Рисунок Б.16 – Висновок


Рисунок Б.17 – Дякую




