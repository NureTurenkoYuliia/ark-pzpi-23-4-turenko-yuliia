МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ










ЗВІТ
з дисципліни «Аналіз та рефакторінг коду» 
з лабораторної роботи №4







Виконала:	Перевірив:
ст. гр. ПЗПІ-23-4	старший викладач каф. ПІ
Туренко Ю.С.	Сокорчук І.П.











ХАРКІВ 2025

СТВОРЕННЯ IОT КЛІЄНТА
1 ІСТОРІЯ ЗМІН

№ДатаВерсія звітуОпис змін та виправлень122.120.1Створено розділ «Завдання»224.120.2Створено UML діаграми прецедентів та діяльності для IoT клієнта325.120.3Додано розділ «Опис виконаної роботи»426.110.4Додано розділ «Висновок» та додатки
2 ЗАВДАННЯ
     Завдання:
* розробити будову програмного забезпечення IoT клієнта;
* створити UML діаграму прецедентів для IoT клієнта;
* розробити бізнес логіку та функції налаштування IoT клієнта;
* створити UML діаграму діяльності для IoT клієнта.
3 ОПИС ВИКОНАНОЇ РОБОТИ
     Зв’язок IoT-клієнта з серверною частиною
     IoT-клієнт реалізований на базі ESP32 і взаємодіє з серверною частиною через HTTP-запити. Серверна частина надає REST API, яке дозволяє IoT-пристрою: передавати сенсорні дані (SensorData), отримувати команди для виконання та повідомляти сервер про виконані команди (ExecutedCommand). 
     В IoT клієнті реалізовано:
* WiFiManager відповідає за підключення до Wi-Fi;
* HttpClient викликає апі POST і GET;
* SensorService емульгує фейкові дані;
* CommandProcessor виконує команди;
* MainLoop все запускає.
     Взаємодія відбувається за класичною клієнт-серверною моделлю, де IoT-клієнт виступає як HTTP-клієнт, а сервер як HTTP-сервер із чітко визначеними апі. Для кожного пристрою використовується deviceId, який передається у URL запиту. Таким чином сервер може ідентифікувати, від якого саме пристрою надійшли дані або для якого пристрою запитуються команди.
     Симулятор та налаштування IoT-клієнта
     Для реалізації IoT-клієнта використовується Wokwi Simulator з платою ESP32 DevKit. Це дозволяє тестувати логіку IoT-пристрою без фізичного обладнання. Основні налаштування винесені в конфігураційний файл (код В.2):
* параметри Wi-Fi;
* базова URL-адреса серверу;
* ідентифікатор пристрою (deviceId);
* інтервали відправки сенсорних даних і перевірки команд.
     Окремо реалізоване налаштування типу пристрою (DeviceType). Один і той самий IoT-клієнт може поводитися по-різному залежно від типу. Це дозволяє без зміни архітектури емулятувати різні типи IoT-пристроїв, що є важливою частиною масштабованості системи.
     Емуляція сенсорних даних
     Оскільки використовується симулятор, реальні фізичні датчики замінені програмною емуляцією. IoT-клієнт генерує:
* температуру;
* рівень pH;
* рівень води.
     Значення формуються у допустимих діапазонах з використанням псевдовипадкових чисел. Кожне значення надсилається на сервер через відповідний endpoint створення SensorData. Таким чином сервер отримує дані в тому ж форматі, що й від реального пристрою; можна перевіряти бізнес-логіку, аналітику та правила тривог без фізичних сенсорів.
     Математика та бізнес-логіка
     IoT-клієнт виконує просту локальну обробку даних: обчислює середнє значення температури, на основі чого розраховує умовний рівень небезпеки. Ця математика демонструє попередню обробку даних без участі серверу.
     Реалізована бізнес-логіка залежить від типу пристрою:
* сенсорний модуль надсилає всі типи сенсорних даних;
* нагрівач працює тільки з температурою;
* лампа реагує лише на команди.
     Також реалізована логіка виконання команд:
* сервер надсилає команди;
* IoT-клієнт виконує їх;
* після виконання надсилає на сервер ExecutedCommand.
     LED-індикатор використовується для візуальної демонстрації виконання команд (увімкнення, вимкнення, калібрування).
     Пояснення main
     Файл main (код В.1) є центральною точкою керування IoT-клієнтом. У ньому:
* ініціалізується Wi-Fi;
* налаштовуються порти та світлодіод;
* запускається основний цикл роботи пристрою.
     В основному циклі:
* з певним інтервалом відправляються сенсорні дані;
* з іншим інтервалом виконується запит до серверу на отримання команд;
* залежно від типу пристрою активуються різні сценарії поведінки.
     Такий підхід чітко розділяє ініціалізацію та бізнес-логіку, дозволяє легко змінювати поведінку пристрою і робить код зрозумілим і розширюваним.
     Діаграми
     У межах розробки проєкту було спроєктовано та візуалізовано архітектуру взаємодії компонентів системи за допомогою мови моделювання UML. Створена діаграма прецедентів (рис. Б.1) описує основні сценарії використання, включаючи налаштування параметрів пристрою, зчитування сенсорних даних та виконання команд.
     Послідовність внутрішніх процесів IoT-клієнта деталізована на діаграмі діяльності (рис. Б.2), яка відображає алгоритм підключення до мережі, обробку даних та механізми виконання команд та запитів. Зокрема, діаграма ілюструє логіку формування JSON-пакетів та перехід пристрою в енергоощадний режим після успішної транзакції. 

4 ВИСНОВОК
     У результаті виконання лабораторної роботи були отримані практичні навички з розробки IoT клієнта, включаючи проектування його архітектури, бізнес логіки, налаштувань, та інтеграцію із серверною частиною. 
ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: https://youtu.be/BKIdLrznX0g .
Хронологічний опис відеозапису:
* 00:00 – Вступ 
* 00:45 – Симулятор 
* 02:36 – Налаштування та url 
* 04:04 – Підключення до мережі 
* 04:13 – HTTP запити 
* 05:22 – Емуляція даних і їх обробка 
* 06:48 – main з викликом функцій 
* 08:03 – Тестування і перевірка взаємодії з сервором 

ДОДАТОК Б
Графічні матеріали

     Рисунок Б.1 – UML діаграма прецедентів для IoT клієнта


     Рисунок Б.2 – UML діаграма діяльності для IoT клієнта

ДОДАТОК В
Програмний код
В.1 main.cpp
1  #include <WiFi.h>
2  #include <HTTPClient.h>
3  #include <ArduinoJson.h>
4  #include "config.h"
5  #include "WiFiManager.h"
6  #include "SensorService.h"
7  #include "CustomHttpClient.h"
8  #include "CommandProcessor.h"
9  
10 #define LAMP_PIN 2
11 
12 void initLamp() {
13   pinMode(LAMP_PIN, OUTPUT);
14   digitalWrite(LAMP_PIN, LOW);
15 }
16 
17 void lampOn() {
18   digitalWrite(LAMP_PIN, HIGH);
19 }
20 
21 void lampOff() {
22   digitalWrite(LAMP_PIN, LOW);
23 }
24 
25 void lampBlink(int durationMs = 2500) {
26   lampOn();
27   delay(durationMs);
28   lampOff();
29 }
30 
31 unsigned long lastSensor = 0;
32 unsigned long lastCommands = 0;
33 
34 void setup() {
35   Serial.begin(115200);
36   delay(500);
37   Serial.println("ESP32 started");
38 
39   initLamp();
40   connectWiFi();
41 }
42 
43 void loop() {
44   Serial.println("Loop running...");
45   unsigned long now = millis();
46 
47   if (now - lastSensor > SENSOR_INTERVAL_MS) {
48     if (DEVICE_TYPE == DEVICE_HEATER) { 
49       SensorReading t = readTemperature();
50       sendSensorData(t);
51 
52       float avg = getAverageTemperature();
53       float danger = calculateDangerLevel(avg);
54 
55       Serial.println("Avg temp: " + String(avg));
56       Serial.println("Danger level: " + String(danger));
57 
58       if (danger > 0.7f) {
59         sendExecutedCommand(3, 3);
60         Serial.println("Auto command triggered");
61         lampBlink(500);
62       }
63     }
64 
65     if (DEVICE_TYPE == DEVICE_SENSOR) {
66       sendSensorData(readPh());
67       sendSensorData(readWaterLevel());
68     }
69 
70     lastSensor = now;
71   }
72 
73   if (now - lastCommands > COMMAND_INTERVAL_MS) {
74     String cmds = fetchCommands();
75     
76     if (processCommands(cmds)) {
77       lampBlink(300); 
78     }
79 
80     lastCommands = now;
81   }
82 
83   delay(5000);
84 }

В.2 config.h
1  #pragma once
2  
3  #define WIFI_SSID "Wokwi-GUEST"
4  #define WIFI_PASSWORD ""
5  
6  #define BASE_URL "https://cleanarium-g8d5eudwdna4gga6.westeurope-01.azurewebsites.net" 
7  #define DEVICE_ID 1
8  
9  enum DeviceType {
10   DEVICE_HEATER = 1,
11   DEVICE_LAMP = 2,
12   DEVICE_SENSOR = 3
13 };
14 
15 #define DEVICE_TYPE 1
16 
17 #define SENSOR_INTERVAL_MS   300
18 #define COMMAND_INTERVAL_MS  15000
19 
20 #define OPTIMAL_TEMP 25.0f
21 #define MAX_TEMP_DEVIATION 5.0f
22 #define TEMP_AVG_WINDOW 5




